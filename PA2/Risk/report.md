# CST 2-1-2 Risk

张益铭  车13  2021010552

**注：本人在2023年春季学期已经完成过本题，因此代码及报告均为2023春的版本，未将代码和报告分享过任何人。**

## 算法思路和实现要点

每一天向前追溯的天数单调不减，可使用队列来存储向前回溯的天数，不断进行入队和出队。在每一次入队和出队时维护当前队列中最大的元素，使用`Queap`即可实现。

`Queap`可用列表实现，内部有两个队列`P,Q`分别当作“优先级队列”和普通队列。

前者每个节点存储当前的最大值和数目，入队时检查入队元素是否比队尾元素大，若是则删除该元素，再将被删除元素存储的数目值加到新入队元素上；否则直接插入队尾，核心代码如下：

```C++
Node *x = P.trailer->pred;
for (Node *p = x->pred; p != P.header && (p->data <= e);) {
    p = p->pred;
    x->count += P.remove(p->succ);
}
```

出队时若队首元素存储数目大于一，则减减，否则将其出队。

得到每一天向前追溯的最大感染人数后，对其进行快速排序，再使用二分查找即可完成。

## 渐进时间复杂度的分析，包含过程

使用`Queap`扫描元素为$O(n)$，排序为$O(n\log n)$，二分查找$O(T\log n)$

总复杂度为$O((n+T)\log n)$。

## 渐进空间复杂度的分析，包含过程

两个队列P和Q使用内存，空间复杂度为$O(n)$


## 遇到的困难和解决方法

需要注意低风险和中风险边界值的开闭，考虑二分查找返回的是不大于被查找元素的最右侧值，需要进行一定处理，以低风险为例：

```C++
uint p_rank = binSearch(d, n, pq[2 * i]);
while (p_rank > 0 && d[p_rank - 1] == pq[2 * i])
    --p_rank;
uint pDay = p_rank + (d[p_rank] != pq[2 * i]);
```

## 估计完成本题所用时间 
四小时
## 关于本题的更多感想

无
